Sample Test Generation Rohan Dahiya ( 16BCI0031 )
Abstract— A very crucial part of the software development process and improving its quality is the labour intensive task of
Software Testing. More than half of the cost, effort and time of software developers is invested on software testing, according
to researchers and software professional. Generating test cases is the most important part when testing software. The testing
can be divided into two types, automatically, or manually through trial and error. We know that, trial-and-error can be
resource and time intensive and is limited by the tester's ability to come up with test cases. Hence, manual method isn't
trustworthy in the longer run when you consider software quality assurance. The focus of this project is to examine and study
the concept and method of automatic sample test case generation which presents us with a more consistent and trustworthy
way of removing human error which is observed during manual test case generation.
S
I. I NTRODUCTION
oftware testing is most essential and integral activity in software development life cycle.
This activity is performed by using a systematic approach. The testing process is a method
of executing a program on a set of test cases and comparing the actual results with the
expected results. Test cases are usually derived from software artifacts such as
specifications and design. Testers initially go through the requirement document to understand
requirements and specifications. After this is done, they start preparing test cases using test case
template. A basic test case template should have details like Test Steps, Test Data, Expected Result,
Actual Result, Pass/Fail and comments. It should have other details like Preconditions, assumptions,
requirement numbers, date, tester name etc. Test Cases are generated automatically using testing
tools OR testers have to manually write test cases.
However, software testing that consists of three phases (test case generation, test execution and test
evaluation) 1 is time consuming activity that requires a lot of resource. Therefore, automated testing
is strived to save resource spent in the terms of time, cost and effort and to give more accurate result
than manual testing that vulnerable to human error.
Test cases are defined as a set of condition or variables which determine the level of correctness and
quality of the product. Simple way to present test case is by providing test path to be followed when
conducting a testing.
II. L ITERATURE R EVIEW
Software testing is an important and critical phase that deals with software quality. However,
software testing that consists of three phases (test case generation, test execution and test
evaluation) 1 is time consuming activity that requires a lot of resource. Therefore, automated testing
is strived to save resource spent in the terms of time, cost and effort and to give more accurate result
than manual testing that vulnerable to human error.
Test cases can be generated automatically from source code or visual software model such as
Unified Modeling Language (UML), Data Flow Diagram (DFD), or Entity Relationship Diagram
(ERD). Research example about code based testing conducted by Srivastaval, et al. used genetic
algorithm to optimize test case generation by applying conditional coverage on source code 2.
Another research from Alazzam et al. used information retrieval techniques for the automatic
extraction of source code concepts for the purpose of test case reduction 3. Compare to code based
testing, model based testing where test cases are generated from model of the software showed
higher efficiency of time and effort. Furthermore, generating test cases in the early phase of
software development life cycle provide control management on construction and testing phase.
Test cases are defined as a set of condition or variables which determine the level of correctness and
quality of the product. Simple way to present test case is by providing test path to be followed when
conducting a testing. The studied literature shows there are various methods described by numerous
researchers for generating test cases and comparing test case from different UML diagrams.
Testing aims at finding errors in a system or program. A set of tests is also called a test suite. Test
case generation is the process of generating test suites for a particular system. Model-based Testing
(MBT) is a technique to generate test suites for a system from a model describing the system. One
usually tries to generate test suite which satisfies a given coverage criterion, e.g., ensuring that parts
of the model are exhaustively exercised. Indeed, exhaustive testing of the implemented system is
usually infeasible (because it would require infinitely many or way too many test cases), but one
would like to increase the likelihood that the selected test suite uncovers errors in the implemented
system.Now
-
a
-
days,  computer  applications  have  diffused  into  every  sphere  of  life,  for  manipulation  of  several 
sophisticated applications. Many of these applications are of very large, complex and safety critical. Thus, 
highly 
reliable  software  is  essential.  In  other  words,  the  good  quality  software  with  high  reliability  is  most  essential. 
Apart from existence of many techniques for increased reliability, software testing is an important and common 
methodology  followed.  S
o,  testing  remains  the  most  important  part  of  quality  assurance  in  the  practice  of 
software  development.  Although  so  many  quality  assurance  techniques  like  formal  specifications,  design 
reviews,  model  checking,  and  inspection,  exists  till  today,  further  fu
rnishing  method  of  testing  is  required  for 
effective testing. Because  software  now has such an important role in our lives both economically and socially, 
there is pressure for software professionals to focus on quality issues. Poor quality software that c
an cause loss of 
life or property is no longer acceptable to society. 
The need for better quality means more pressure for software testing and for test engineers taking care of it. 
Software Testing is the process of executing a program with the intention
of finding errors. Every software code 
has  been  reviewed  and  verified  through  Software  Quality  and  Assurance  activities  but  these  activities  are  not 
sufficient. Every time the software delivered to the client has been thoroughly tested by client before se
nding it to 
the  production.  Thus  QA  Team  has  to  test  the  software  before  it  gets  to  the  client.  Testing  information  flow  is 
said  to  be  as  a  testing  technique  which  specifies  the  strategy  to  select  input  test  cases  and 
analyze
test  results. 
Most software en
gineers would agree that testing is a vital component of a quality software process, and is one of 
the  most  challenging  and  costly  activities  carried  out  during  software  development  and  maintenance.  The 
software Testing process has been described as a seri
es of phases, procedures, and steps that result in Delivering 
Quality Software Product to the production. Testing thus can be described as a process used for revealing defects 
in  software,  and  for  establishing  that  the  software  has  attained  a  specified  deg
ree  of  quality  with  respect  to 
selected attributes.
Some Researcher has derived the automatic test cases using class diagram, sequence diagrams and state chart 
Diagram, but not considered Use case diagram functionality. In
this paper, we use UML class dia
gram, sequence 
diagrams  and  state  chart  Diagram
,  Use  case  diagram
as  design  specifications,  and  implemented  the  idea  of 
parsing the Petal files to generate the collaborative Test cases from these UML Diagrams using Pattern Discovery 
and  Information  Retriev
al  process.  Rational  Rose  tool  has  been  used  to  produce  a  model  of  system  design
.
We 
proposed a novel approach for automated test case generation from 
these four 
UML diagrams for object oriented 
applications  based  on  the  behavior.  This  thesis  implements  th
is  framework  with  the  development  of  a  tool 
integrates all types of automated
test case generation from four
UML diagrams in an object oriented application.
Vol. 4 Issue 1 June 2014
31
ISSN: 2319 
–
1058
International Journal of Innovations in Engineeri
ng and Technology (IJIET)
The  paper  is  structured  in  the  following  way:  In  next  section,  we  presented  related  work  of  generating  test 
cases by using different UML Diagrams. In section 3, we proposed methodology for Test case generation, while 
section  4,  w
e  discussed  the  implementation  of  our  approach  with  a  case  study  and  describe  the  experimental 
evaluation  of  the  proposed  model. Then  after  a  clear  Conclusion,  last  section  concluded  the  paper  and  gives  an 
overview of our work.
II. R
ELATED
W
ORK
Philip Sa
muel, Rajib Mall and Sandeep Sahoo have presented a novel testing methodology to test object
-
oriented 
software  based  on  UML  sequence  diagrams  [7].  This  paper  has  presented  an  approach  to  generate  test  cases 
automatically  from  UML  sequence  diagrams  using  dy
namic  slicing  technique  [7].  Monalisa  Sarma,  Debasish 
Kundu, Rajib Mall have presented a novel approach of generating test cases from UML design diagrams [9].
Santosh Kumar Swain, Durga Prasad Mohapatra, and Rajib Mall have presented a strategy for integr
ation testing 
which  combines  information  from  use  case  and  sequence  diagram.  This  methodology  predominantly  uses  the 
sequence diagram of UML 2.0 for generation of test cases [3].
Supaporn Kansomkeat, Jeff Offutt, AynurAbdurazik, Andrea Baldini presents a 
single project experiment on the 
fault revealing capabilities of model
-
based test sets [4].
Puneet  E.  Patel,  Nitin  N.  Patil  generates  test  cases  from  activity  diagram.  Also  a  test  coverage  criterion,  called 
activity path coverage criterion has been imple
mented [1].A.V.K. Shanthi1 and G. Mohan Kumar focuses on test 
cases  generation  by  means  of  UML  Sequence  diagram  using  Genetic  Algorithm  which  best  test  cases  are 
optimized and the test cases validated by prioritization. For generating the test case  from th
e sequence diagram, 
they first extract the necessary information from the diagram. For that write parser in java to extract all possible 
information  from  file.  Based  on  the  extracted  information,  a  Sequence  Dependency  Table  (SDT)  is  generated. 
With the hel
p of SDT test path are generated, by applying the GA most prioritized test case are generated [13].
Supaporn and Wanchai have proposed the automatic testing technique to solve partially the testing process [11]. 
This  research  paper  has  presented  an  attemp
t  to  generate  test  cases  from  TFG  (Testing  flow  graph)  and  then 
select  test  cases  to  detect  any  fault.  Firstly,  state  chart  diagram  has  been  altered  to  graph  called  TFG  (Testing 
flow graph) [11]. Secondly, test cases have been generated by traversing the  f
low graph and using the coverage 
criteria of the state and transition of diagrams. Finally, using mutation analysis test cases have been evaluated to 
detect any fault [11].
Li Bao
-
Lin, Li Zhi
-
shu, Li Qing and Chen Yan Hong have presented a new test cases g
eneration approach that is 
based  on  UML  sequence  diagrams  and  Object  Constraint  Language/OCL  [8].  The  sequence  diagram  has  been 
transformed  to  a  tree  representation.  Firstly  by  selecting  conditional  predicates  from  sequence  diagram  whole 
constructed tree h
as been traversed. Then, pre and post conditions have been applied with the help of OCL. OCL 
alter  the  conditional  predicates  on  sequence  diagram  and  thus  test  cases  have  been  generated  by  applying 
function minimization technique [8].
A.V.K  Shanthi,  Dr.  G.
Mohan  kumar  proposed  setting  up  several  tests  adequacy  criteria  with  respect  to  class 
diagrams,  an  automatic  approach  is  presented  to  generate  test  cases  for  Object  oriented  programs  using  Data 
mining searching techniques[14]. Yi
-
Tin Hu and Nai
-
Wei Lin us
e UML class diagrams and the Object Constraint 
Language  to  describe  the  specification  of  Java  methods.  The  automatic  generation  of  test  cases  is  based  on  the 
unification  mechanism and the  powerful constraint solving  mechanism of constraint logic  programmin
g [37].P. 
Samuel  R. Mall A.K. Bothra  has developed a novel  method to automatically generate test cases based on UML 
state models. The test cases generated satisfy transition path coverage criteria and can be used to test cluster
-
level 
state
-
dependent  behav
iors  [12].  Chayanika  Sharma  discussed  the  applications  of  GA  in  different  types  of 
software testing. The GA is also used with fuzzy as well as in the neural networks in different types of testing. It 
is found that by using GA, the results and the performan
ce of testing can be improved [15].
Pakinam N. Boghdady, Nagwa L. Badr, Mohamed A. Hashim, Mohamed F. Tolba[2] proposes an enhanced    
XML
-
based automated approach for generating test cases from activity diagrams. The proposed architecture 
crea
tes a special table called Activity Dependency Table (ADT) for each XML file.
M. Prasanna and K. R. Chandran [6] suggested “Automatic Test Case Generation for UML Object diagrams using
Genetic Algorithm. Class collaboration testing will be accomp
lished in similar way as testing of individual class 
occurs. They have used language such as Object Constraint Language/OCL [17] or a natural language, and/or as a 
state transition diagram to generate test cases for a class.
Vol. 4 Issue 1 June
2014
32
ISSN: 2319 
–
1058
International Journal of Innovations in Engineering and Technology (IJIET)
Information  from  all  these  diagrams  have  been  accumulated  and  whichever  form  is  most  consistent  is  used  to 
develop  test  cases.  They  used  operations  of  c
lasses  to  generate  test  cases  and  execution
-
based  testing  to  test  the 
class. In execution based testing assertion checks has been added to the class code to find the bugs.
Some  more  research  has  been  reported  to  generate  test  cases  based  on  class  [18].  For
testing  these  two  types  of 
diagrams a control flow graph has been developed that contains multiple entities. Now the entire traditional graph 
based test coverage techniques can be applied to this control flow graph as outlined in [18]. This includes branc
h 
coverage,  path  coverage  and  round  trip  scenario  coverage  criteria  [19].  Since  UML  diagrams  are  always  more 
abstract and provides ease  to generate  test cases than control flow  graphs  so researchers have started  using UML 
diagrams to generate automated tes
t cases from UML diagrams.
Mary V. Ashley, Isabel C. Caballero [16] presented a new optimization framework for sibling reconstruction from 
single generation microsatellite genetic data. Binder has also presented some work to generate test cases from state
chart  diagram.  He  also  proposes  a  new  method  called  state  reporter  method  that  effectively  access  and  report 
internal state information whenever invoked [19]. Ranjita swain, P. K. Behara, D. P. Mohapatra also presented an 
approach for generated the Automa
tic Test Case from UML State Chart Diagram from function minimization [20].
III
. M
ETHODOLOGY FOR
T
EST
C
ASES
G
ENERATION
Generally  test  cases  have  been  generated  from  individual  UML  diagram,  but  the  test  cases  generated  by  single 
diagram are not effective
and efficient because test cases that have been generated depend on single view only. If 
combination of diagrams has been used then test cases generated will be  more efficient and effective as they  will 
cover both static and dynamic aspects of the system.
Thus  the  system  focuses  on  the  different  UML  diagrams  for  test  cases  generation:  Class  Diagram,  Sequence 
Diagram
, 
State  chart  Diagram
and  use  case  Diagram
.
Various  types  of  information  can  be  extracted  from  these 
diagrams to generate test cases.
For sta
tic information class diagrams have been used and for dynamic type of information sequence and state chart 
diagrams  have  been  used.  Class  diagram  has  been  used  to  get  the  information  related  to  Classes,  Relationship 
between  classes/Association,  Dependency,
Generalization/  Parent
-
child  relationship,  Operations,  Cardinality,  and 
Attribute.
Sequence  diagram  has  been  used  to  get  the  information  about  Object  interactions  i.e.  messages  sent  to 
other objects, Precondition for a particular message, Post
-
condition f
or a particular message.
State  chart  diagram  has  been  used  to  get  the  information  about  Initial  state  of  a  system,  final  state  of  a  system, 
Guard  conditions,  Transitions.  Combination  of  class,  sequence  and  state  chart  diagrams  i.e.  all  the  required 
inform
ation from each diagram has been extracted to generate test cases for a particular system.
Use Case Diagrams can be used to describe the functionality of a  system in a  horizontal way. That is, rather than 
merely representing the details of individual featu
res of your system, 
UCDs can be used to show all of its available functionality.
Use case diagrams
represent the functions of a system 
from  the  user's  point  of  view
.
This
show
s
business  use  cases,  actors,  and  the  relationships  between  them.  The 
relations
hips  between  actors  and  business  use  cases  state  that  an  actor  can  use  a  certain  functionality  of  the 
business system.
Following are the major steps in prepared technique:
1)
Input UML Diagram Petal Files: The Petal  file of class, sequence and state chart d
iagrams and Use Case 
Diagram has been given as input to the developed tool GUI. 
2)
Parsing petal File: Petal file has been parsed by the tool by parsing tokens and string matching mechanism 
has  been  used  to  find  a  pattern  like  class  name,  class  attributes, 
class  cardinality,  class  operations, 
inheritance, dependency etc. 
3)
Is pattern found: If pattern has been found then it is temporarily  stored in the  designated buffer else  next 
pattern has been found. 
4)
Store  it  in  a  Buffer:  All  patterns  found  have  been  st
ored  in  a  designated  buffer.  There  are  different 
temporary buffers for every pattern like class name buffer, class attributes buffer, class cardinality buffer, 
class operations buffer, inheritance buffer, dependency buffer etc. 
Vol. 4 Issue 1 June 20
14
33
ISSN: 2319 
–
1058
International Journal of Innovations in Engineering and Technology (IJIET)
5)
Search for another pattern: Then searches for various patterns in petal file. For example if class name has 
been found then class name has been entered in
to the class name buffer else if class attributes has been 
found, then appends it to the class attributes buffer similarly so on. 
6)
Is EOF (End of File): System keeps on searching the patterns until EOF? 
7)
Create  bulk  insert  query  from  buffer  and  store  it 
in  database:  When  end  of  file  has  been  reached,  then 
generates  the  bulk  insert  query  to  minimize  the  Database  access  which  contains  all  data  about  class 
diagram in form of tuples which can be executed and insert the information into database. 
8)
Parsing all
Petal files: After class diagram, Petal  files of sequence diagram and state chart diagram and 
Use case Diagram have been parsed sequentially through same process. 
9)
Extract strings to generate  test cases: The  database  which contains the  information  from  c
lass diagram, 
sequence  diagram,  state  chart  diagram
and  Use  case  Diagrams  has  been  used  to  generate  test  cases  by 
extracting  the  correlating  information.  System  has  been  implemented  to  generate  automated  test  cases 
from these diagrInternational Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
Automatic Software Test Case Generation: An Analytical
Classification Framework
Mohammad Reza Keyvanpour 1 , Hajar Homayouni 1 and Hossein Shirazee 2
1
Computer engineering department, Alzahra University, Tehran, Iran
2
Computer engineering department, Islamic Azad University,
Qazvin Branch, Qazvin, Iran
keyvanpour@alzahra.ac.ir
Abstract
A challenging part of software testing entails the generation of test cases. A good test case
should have the quality to cover more features of test objective. The techniques for automatic
generation of test cases try to efficiently find a small set of cases that allow an adequacy
criterion to be fulfilled, thus reducing the cost of software testing and resulting in more
efficient testing of software products. In this paper we introduce an all-around classification
framework for automatic test case generation approaches in terms of test type and Algorithm,
and represent some test case evaluation approaches. Finally we illustrate a comparison
between different existing techniques.
Keywords: software testing; test case generation; Automation, classification
1. Introduction
Software testing is the process of executing a program in order to find faults. Testing is a
very important, though expensive phase in software development and maintenance; it has
been estimated that software testing entails between 30 percent and 50 percent of software
development [1]. A challenging part of this phase entails the generation of test cases. This
generation is crucial to the success of the test because it is impossible to achieve a fully tested
program given that the number of test cases needed for fully testing a software program is
infinite, and a suitable design of test cases will be able to detect a great number of faults. For
these reasons, the techniques for automatic generation of test cases try to efficiently find a
small set of cases that allow an adequacy criterion to be fulfilled, thus reducing the cost of
software testing and resulting in more efficient testing of software products. A test case is a
set of tests performed in a sequence and related to a test objective, which will produce a
number of tests comprising specific input values, observed output, expected output, and any
other information needed for the test to run, such as environment prerequisites [2]. A good
test case should have the quality to cover more features of test objective. The techniques for
the automatic generation of test cases try to efficiently find a small set of cases that allow a
given adequacy criterion to be fulfilled, thus contributing to a reduction in the cost of
software testing [1].
There have been few efforts on representing an all-around classification, which covers all
existing automatic test case generation approaches. In this paper we introduce a general
1International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
classification for automatic test case generation approaches in terms of test type and the
Algorithm, and will define a comparison between these approaches.
The rest of the paper is organized as follows. Section 2 is an overview on classifications of
automatic test case generation approaches. In Section 3 we read about the requirements,
applications, and challenges of automating test case generation, Section 4 and 5 are
classifications of techniques, section 6 is about test case evaluation approaches, and the last
sections are conclusions and future work.
2. Overview
There has been a significant amount of work in automatic test case generation that attempts
to increase the amount of observed behavior. Despite of these wide researches, there have
been few efforts on representing an all-around classification, which covers all existing
automatic test case generation approaches. A general classification for these techniques is
presented in [3, 4, 5]. In [6] a classification framework for automatic test case generation
methods is presented which is based on software development phase in which testing is
applied. In [7] a classification of search-based automatic test case generation approaches is
represented.
In this study, we introduce a comprehensive classification and evaluation of automatic test
case generation techniques, which tries to cover all existing approaches.
3. Automatic Test Case Generation
Generally speaking there are different reasons to automate test case generation task in
software testing. Some of the most important reasons are as follows.
Reducing the cost of software testing: During testing phase the cost can increase more than
the expected value due to inappropriate test cases. These inappropriate test cases cause
wastage of organizational resources as well as time. There is a need to minimize the cost for
getting an acceptable product [8].
Reducing human errors: In order to find out how a test case is valid there is no definite
mechanism. It basically depends on the testers understanding of the requirement. In this
process there are lots of human errors and tester basic skill level taken into consideration.
This leads to the inclusion of bugs in the system after testing. To overcome this problem,
automatic test case generation phase should be considered [9].
Increasing software products quality: It is generally agreed that manual testing is becoming
a bottleneck and is a frequent cause of project delays especially for large programs. Therefore,
automatic test case design has become important to ensure the quality of present day large
software products [10].
Reducing number of test cases: Generation efficient test cases are the essential passport for
simplifying the test work and improving the test efficiency. The test work is inefficient
because of the great number of the initial test cases, so some Automation algorithms are
needed to optimize the test cases [11].
2International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
Covering all system requirements: Automating the test case generation process provides a
means to ensure that test cases have been derived in a consistent and objective manner and
that all system requirements have been covered [12].
The applications of automatic test case generation are as wide as software applications. In
general, software systems can be classified to three main classes. Figure 1 shows this general
classification and some examples for each group. Automating test case generation can be
done for testing any of these groups, depending on their complexity and size.
Figure 1. Software Classification
There are some challenges in automating test case generation, to be answered:
 What types of methods are there available at our disposal?
 What are the characteristics and underpinnings of different algorithms?
 How to determine which method is appropriate for what type of test case
generation task?
 Which methods can be used to make headway in what aspect of the essential
difficulties in test case generation?
 When to apply test case generation in software life cycle?
 What should be the inputs for a test case generation system?
4. Proposed Classification Framework in Terms of Test Type
There are different types of software testing approaches. Respecting to the fact that test
case generation is an important phase in software testing, test case generation approaches
directly depends on the type of software testing. Table 1 represents a classification for
different automatic test case generation approaches in terms of test type.
3International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
Table 1. Classification Framework in Terms of Test Type
5. Proposed Classification Framework in Terms of Algorithm
Table 2 presents a classification framework for automatic test case generation approaches
based on the kind of algorithm they used.
4International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
Table 2. Classification Framework in Terms of Algorithm
To illustrate, some examples of using mentioned algorithms are expressed as follows.
5.1. Random-based Automatic Test Case Generation
As it is mentioned before, this algorithm is mostly used to analyze the efficiency of other
algorithms in comparison with it.
5.2. Search-based Automatic Test Case Generation
There are a variety of search algorithms to use for the purpose of test case generation.
Figure 2 shows these search-based methods.
5International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
Figure 2. Search-Based Methods
5.2.1. Automatic Test Case Generation using Hill Climbing: Hill climbing (HC) is a
local search algorithm. It needs that a neighborhood N of the current sequence Si is defined.
The search will move to a new solution Sj  N only if Sj is better. If there are no better
solutions in N, a local optimum has been reached. In such a case, a restart of the algorithm
from a new random solution can be done. Andrea Arcuri and Xin Yao [4] automatically
generated test cases for structural testing of Java containers using Hill Climbing. A solution to
the problem is a sequence Si of Function Calls (FCs) on an instance of the Container under
Test (CuT). A Function Call (FC) can be seen as a triple: < object reference; function name;
input list >. They used three types of operations on Si for generating N: Removal of a single
FC from Si, Insertion of a new FC in Si, and Modification of the parameters of a FC.
In general HC is a simple algorithm but may lead to a local optimum.
5.2.2. Automatic Test Case Generation using Genetic Algorithm: Genetic algorithms
[4] represent a class of adaptive search techniques and procedures based on the process of
natural genetics and Darwin’s principle of the survival of the fittest. Genetic algorithm
searching mechanism starts with a set of solution called a population. One solution in the
population is called a chromosome. The search proceeds for a number of generations, for each
generation the fitter solutions (based on the fitness function) will be selected to form a new
population. During the cycle, there are three main operators namely reproduction, crossover
and mutation. The cycle will repeat for a number of generations until certain termination
criteria are met.
In [14] a method of generating test cases for structural testing based on genetic algorithms
to cover multiple target paths in one run is presented. First, the problem of generating test
cases is formulated as a multi-objective optimization problem in which the number of
objectives decreases along with generation of test cases. Then, test cases are generated using
genetic algorithms incorporating with domain knowledge.
In [19] a Constraint-based Genetic Algorithm technique is used to generate optimized test
cases from UML Activity diagram and Collaboration diagrams. [11] Is about test cases
generated for software security based on GA. The method selects the most favorite test cases
in order to discover the vulnerabilities in the software. This method can reduce the test time
and improve the test efficiency to a certain extent. The probability of selection Pi is decided
according to the fitness value fi of the test case di in this algorithm.
6International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
(1)
Where n is the number of the test cases in the group and,
(2)
In [18] some new categories of genetic codes are applied in some problem optimizations
for the generation of reliable software test cases based on the specification of the software.
Figure 3 shows the GA algorithm used.
Figure 3. GA Algorithm
The simulation shows that the proposed GAs with the specification can find solutions with
better quality in shorter time. All in all, genetic algorithm is the most favorite algorithm used
in test case generation task till now, as a result of leading to acceptable test suits.
5.2.3. Automatic Test Case Generation using Genetic Programming: genetic
programming (GP) is an evolutionary algorithm-based methodology inspired by
biological evolution to find computer programs that perform a user-defined task. It is a
specialization of genetic algorithms (GA) where each individual is a computer program.
It is a machine learning technique used to optimize a population of computer programs
7International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
according to a fitness landscape determined by a program's ability to perform a given
computational task.
[20] Presents a search-based approach to automatically generating test cases for
object oriented software. It relies on a tree-based representation of method call
sequences. Strongly-typed genetic programming is employed to generate method call
trees which respect the call dependences among the methods. A new kind of distance-
based fitness function applied that accounts for runtime exceptions. The approach
proved successful and produced test cases leading to full branch coverage for four test
objects completely automatically.
5.2.4. Automatic Test Case Generation using Memetic Algorithm: The Memetic
algorithms (MAs) are metaheuristics that use both global and local search (e.g., a GA
with a HC). It is inspired by the cultural evolution. A meme is a unit of imitation in
cultural transmission. The idea is to mimic the process of the evolution of these memes.
From an optimization point of view, a MA can be described as a population based
metaheuristic in which, whenever an offspring is generated, a local search is applied to
it until it reaches a local optimum.
The MA used in [4] for testing of object-oriented containers is fairly simple. It is
built on GA, and the only difference is that at each generation on each individual a Hill
Climbing is applied until a local optimum is reached. The cost of applying those local
searches is high, hence the population size and the total number of g enerations is lower
than in the GA.
5.2.5. Automatic Test Case Generation using Tabu search: Tabu Search (TS) is a
metaheuristic search technique based on the premise that, in order to qualify as
intelligent, problem solving must incorporate adaptive memory and responsive
exploration. Thus, the algorithm of Tabu Search is based on that of the next k neighbors,
while maintaining a Tabu list (memory) of visited neighbors that are forbidden. The
Tabu Search algorithm has a number of parameters that have to be chosen on the basis
of the problem to be solved: the objective function (fitness function) which has to
measure the cost of a solution, an appropriate Candidate list strategy (to try to choose
good neighbor candidates that goes beyond a local optimum without exploiting the
examination of elements in the neighborhood) and, it is also necessary to define short -
term memory and long-term memory and their respective strategies. Short-term memory
stores the recent moves of the search as Tabu. Long-term memory, on the other hand,
stores the frequency with which a move occurs in order to penalize frequently visited
moves that diversify the search. TSGen [21] is a Tabu search metaheuristic algorithm
for the automatic generation of structural software tests. The goal that TSGen has to
achieve is that of generating the tests that obtain the maximum branch coverage for the
program under test. Figure 4 shows the scheme of this tool. [22] Created an efficient
testing technique that combines Tabu Search with Korel’s chaini ng approach. The
technique automatically generates test data in order to obtain branch coverage in
software testing.
8International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
Figure 4. TSGen Tool [21]
5.2.6. Automatic test case generation using Simulated Annealing: Simulated Annealing is
similar in principle to Hill Climbing. However, by allowing for a probabilistic acceptance of
poorer solutions, Simulated Annealing allows for less restricted movement around the search
space. The probability of acceptance P of an inferior solution changes as the search
progresses, and is calculated as
  
Where  is the difference in objective value between the current solution and the
neighboring inferior solution being considered, and t is a control parameter known as the
temperature. The temperature is cooled according to a cooling schedule. Initially the
temperature is high, in order to allow free movement around the search space, and so that
dependency on the starting solution is lost. As the search progresses, the temperature
decreases. However, if cooling is too rapid, not enough of the search space will be explored,
and the chances of the search becoming stuck in local optima are increased.
The work of Tracey and co-authors [23, 24] applies Simulated Annealing to structural test
data generation, in the hope of overcoming some of the problems associated with the
application of local search. In this work, test case can be generated for specific paths, or for
specific statements or branches. In order to apply Simulated Annealing, a neighborhood
structure has to be defined for the various different input variable types. The objective
function is simply the branch distance of the required branch when control are diverges away
from the intended path, or away from the target structure down a critical branch.. In [25] a
new automatic test case generation approach is presented based on Length-N coverage
criterion through genetic simulated annealing algorithm. Firstly, a new test coverage criterion
called Length-N is proposed to aim at the feasible of path coverage criteria. To enhance the
generated efficiency, some improvements are made on genetic simulated annealing algorithm
and use the results to generate test data. Lastly, experiment results show the method has a
better effect.
9International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
5.2.7. Automatic Test Case Generation using Scatter Search: Scatter Search is an
evolutionary method that works on a population of solutions of the problem to be solved,
which are stored in a set of solutions called the Reference Set.
The solutions in this set are combined in order to obtain new ones, trying to continually
generate better solutions, according to quality and diversity criteria. [26] Presents an approach
based on the metaheuristic technique Scatter Search for the automatic test case generation of
BPEL business processes using a transition-pair coverage criterion. The test case generator is
called TCSS-LS-for-BPEL and it combines a diversity property with a local search. The
diversity property is used to extend the search of test cases in order to reach different
transitions of the business process. The local search is used to intensify the search when the
diversification has problems to find test cases that cover transitions that have not been
covered yet. Figure 5 shows the algorithm schema.
Figure 5. Scatter Search Schema [26]
5.3. Data Mining-based Automatic Test Case Generation
[16] Presents a novel methodology for identifying important test cases automatically using
neural networks. These test cases involve input attributes which contribute to the value of an
output and hence are significant. The reduction in the number of test cases is attributed to
identifying input-output relationships. A ranked list of features and equivalence classes for
input attributes of a given code are the main outcomes of this methodology. Reducing the
number of test cases results directly in the saving of software testing resources. The proposed
testing methodology is essentially a black-box testing approach employing a NN. The focal
idea is to perform I-O analysis on the given piece of code. A trained neural network is pruned
and rules are extracted from the pruned network. The significant inputs for a particular output
are identified. The test cases involving unrelated attributes can be eliminated from a
combinatorial set of test cases for a particular output.
10International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
6. Classification of Test Case Generation Evaluation Approaches
There are different ways to evaluate generated test cases; some of these approaches which
are mostly used in mentioned automatic test case generation approaches will be described.
6.1. Number of Faults Detected (mutation testing): the effectiveness of test cases can be
evaluated using a fault injection technique called mutation analysis. Mutation testing is a
process by which faults are injected into the system to verify the efficiency of the test cases.
Mutation-based analysis is a fault based testing strategy that starts with a program to be tested
and makes numerous small syntactic changes into the original program. Program with
injected faults are inserted and tested in the following manner. One faulty version of program
is created at a time and run against all test cases one by one until either fault is revealed or all
test cases are executed. A fault is considered to be revealed if the output of faulty version of
program is different from the original program on same input. If a test case set is capable of
causing behavioral differences between original program and mutant, mutant is considered as
killed by test. The product of mutation analysis is a measure called mutation score, which
indicated the percentage of mutants killed by a test set [17, 27].
(3)
6.2. Coverage Criteria: One critical task in software testing is to generate test case to satisfy
given adequacy criteria. Given a coverage criterion, the problem of generating test case is to
search for a set of test cases that lead to the highest coverage when given as input to the
software under test.
As an example Branch coverage [14] means the percentage of no of edges/branches of the
control flow graph covered by the test suit. The branch coverage factor for any test suit, T
here is denoted as R (T). To evaluate this, firstly control flow graph of the program is created.
Then, for each test case of a test suit, evaluate the set of branches that has been covered. Take
the union of all the evaluated set of branches. Count the number of elements of the resultant
set (let it be n). At the last, Branch coverage is evaluated as:
R (T) =n/e
(6)
Where e is the total number of edges of control flow graph. Some other examples are path
coverage, condition coverage, and statement coverage explained in [28, 29, 30] respectively.
6.3. Input/output Analysis: Having a large set of expected input /outputs of a program under
test, a good test set can be a set of test cases that finds the most mismatch between real inputs
and outputs of a program.
6.4. Data Mining Approaches: it might be useful to have a mechanism that is able to learn,
based on past history, which test cases are likely to yield more failures versus those that are
not likely to uncover any. In fact the fault exposure capability of newly generated test cases
can be predicted. Some features of test cases are extracted such as test case length and various
coverage metrics relevant to the testing strategy used, and levels of severity of faults detected
by those test cases can be found out [31].
11International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
8. Discussions
Figure 6 shows automatic test case generation system architecture, in terms of test type.
The results of comparing different mentioned techniques are presented in table 3 and table 4.
Table 3 shows a comparison between approaches in terms of test type, and Table 4 shows a
comparison between approaches in terms of algorithm.
Figure 6. Automatic Test Case Generation System Architecture
Table 3. Automatic Test Case Generation Approaches in Terms of Test Type
12International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
Table 4. Automatic Test Case Generation Approaches in Terms of Algorithm
7. Conclusion
In this paper we represented two different classification frameworks for the existing
automatic test case generation approaches, and also have a brief look at each one. We
described how to evaluate generated test cases, and introduce a classification of evaluation
approaches. The results show that different approaches should be selected based on types of
applications, features of software we want to test, technique’s complexity, and other features.
Although there have been lots of researches on automatic test case generation problem, but
for real world systems more researches are still needed.
Acknowledgements
This work is supported by Alzahra university of Tehran, computer engineering department.
The authors are grateful to anonymous referees of this paper for their constructive comments.
References
[1] R. Blanco, J.Tuya and B. Adenso-Díaz, “Automated test data generation using scatter-search approach”,
Information and Software technology, vol. 51, Issue 4, (2009), pp. 708-720.
[2] B. N. Biswal, S. S. Barpanda and D. P. Mohapatra, International Journal of Computer Applications, vol. 1,
Issue 14, (2010).
[3] R. Jeevarathinam and A. S. Thanamani, “Towards Test Cases Generation from Software Specifications”,
International Journal of Engineering Science and Technology, vol. 2, Issue 11, (2010), pp. 6578-6584.
[4] A. Arcuri and X. Yao, “Search based software testing of object-oriented containers”, Information Sciences,
vol. 178, no. 15, (2008) August, pp. 3075-3095.
[5] E. Alba and F. Chicano, “Observations in using Parallel and Sequential Evolutionary Algorithms for
Automatic Software Testing”, Computers & Operations Research, vol. 35, no. 10, ( 2008) October, pp. 3161–
3183.
[6] M. Prasanna, S. N. Sivanandam, R. Venkatesan, R. Sundarrajan, “A Survey on Automatic Test Case
generation”, Academic Open Internet Journal, vol. 15, (2005).
[7] P. McMinn, “Search-based software test data generation: A survey”, Software Testing, Verification &
Reliability, vol. 14, no. 2, (2004) June, pp. 105–156.
[8] A. Sharma, A. Jadhav, P. R. Srivastava and R. Goyal, “Test cost optimization using tabu search”, J. Soft. Eng.
Appl., vol. 3, no. 5, (2010), pp. 477–486.
[9] V. Rajappa, A. Biradar, S. Panda, “Efficient software test case generation using genetic algorithm based
graph theory”, Proceedings of the First International Conference on Emerging Trends in Engineering and
Technology, (2008), pp. 298-303.
13International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
[10] S. K. Swain, D. P. Mohapatra and R. Mall, “Test case generation based on state and activity models”, Journal
of Object Technology, vol. 9, no. 5, (2010), pp. 1 – 27.
[11] Q. Li and J. Li, Proceedings of the International Symposium on Intelligent Information Systems and
Applications, ( 2009).
[12] S. J. Cunning and J. W. Rozenblit, “Test scenario generation from a structured requirements specification”,
journal of Intelligent and Robotic Systems, vol. 41, no. 2-3, (2005), pp. 87-112.
[13] W. T. Tsai, D. Volovik, T. F. Keefe and M. E. Fayad, “Automatic Test Case Generation from Relational
Algebra Queries”, IEEE Transactions on Software Engineering, vol. 16, no. 3, (1990).
[14] G. Dunwei, Z. Wanqiu and Z. Yan, Chinese Journal of Electronics, vol. 19, no. 2, (2011).
[15] A. Alhroob, K. Dahal, A. Hossain, “Automatic Test Cases Generation from Software Specifications”, e-
Informatica Software Engineering Journal, vol. 4, Issue 1, (2010).
[16] P. Saraph, M. Last and A. Kandel, “Test Case Generation and Reduction by Automated Input-Output
Analysis”, IEEE International Conference on Systems, Man & Cybernetics (SMC 2003), Washington, D.C.,
USA, (2003) October 5-8, pp. 768-773.
[17] K. Singh, International Journal of Engineering Science and Technology, vol. 2, Issue 11, (2010).
[18] K. Singh and R. Kumar, International Journal of Innovation, Management and Technology, vol. 1, no. 1,
(2010).
[19] B. N. Biswal, S. S. Barpanda and D. P. Mohapatra, International Journal of Computer Applications, vol. 1,
Issue 14, (2010).
[20] S. Wappler and J. Wegener, “Evolutionary testing of object-oriented software using a hybrid evolutionary
algorithm”, IEEE Congress on Evolutionary Computation, (2006).
[21] E. Díaz, J. Tuya, R. Blanco and J. J. Dolado, “A Tabu Search Algorithm for Structural Software Testing”,
Journal Computers and Operations Research, ACM, vol. 35, no. 10, (2008), pp. 3052–3072.
[22] E. Díaz, J. Tuya and R. Blanco, “Automatic Software Testing Using a Metaheuristic Technique Based on
Tabu Search”, 18th IEEE International Conference on Automated Software Engineering, Montreal, (2003),
pp. 301-313.
[23] N. Tracey, J. Clark, K. Mander and J. McDermid, “An automated framework for structural test-data
generation”, In Proceedings of the International Conference on Automated Software Engineering (1998),
Hawaii, USA, IEEE Computer Society Press, pp. 285-288.
[24] N. Tracey, J. Clark, K. Mander, “The way forward for unifying dynamic test-case generation: The
optimisation-based approach”, In International Workshop on Dependable Computing and Its Applications
(1998), Dept of Computer Science, University of Witwatersrand, Johannesburg, South Africa, pp. 169-180.
[25] H. Waeselynck, P. T. Fosse and O. A. Kaddour, “Simulated annealing applied to test generation: landscape
characterization and stopping criteria”, Empir Software Eng, vol. 12, no. 1, (2007), pp. 35-63.
[26] R. Blanco, J. Fanjul and J. Tuya, “Test case generation for transition-pair coverage using Scatter Search”,
International Journal of Software Engineering and Its Applications, vol. 4, no. 4, (2010).
[27] M. Prasanna, K.R.Chandran, K. Thiruvenkadam, “Automatic testcase generation for UML collaboration
diagram”, IETE Journal Of Reasearch, vol. 57, no. 1, (2011), pp. 77-81
[28] L. Lanzarini, J. Pablo and L. Battaglia, JCS&T, vol. 10, no. 2, (2010).
[29] H. Tahbildar and B. Kalita, “Heuristic Approach of Automated Test Data Generation for Programs Having
Array of Different Dimensions and Loops with Variable Number of Iterations”, International Journal of
Software Engineering & Applications (IJSEA), vol. 1, no. 4, (2010).
[30] M. Alzabidi, A. Kumar, A. D. Shaligram, “Automatic Software Structural Testing by Using Evolutionary
Algorithms for Test Data Generations”, IJCSNS International Journal of Computer Science and Network
Security, vol. 9, no. 4, (2009).
[31] C. Anderson, A. Mayrhauser, R. Mraz, “On the Use of Neural Networks to Guide Software Testing
Activities”, Proceedings of the IEEE International Test Conference on Driving Down the Cost of Test (1995),
IEEE Computer Society, Washington, DC, USA, pp. 720-729.
14International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
Authors
Mohammad Reza Keyvanpour
Mohammad Reza Keyvanpour is an Assistant Professor at Alzahra
University, Tehran, Iran. He received his B.S. in Software
Engineering from Iran University of Science &Technology, Tehran,
Iran. He received his M.S. and Ph.D. in Software Engineering from
Tarbiat Modares University, Tehran, Iran. His research interests
software testing.
Hajar Homayouni
Hajar Homayouni received his B.S. in Software Engineering from
University Of Kashan, Isfahan, Iran. Currently, she is pursuing M.S. in
Software Engineering at Alzahra University, Tehran, Iran. His research
interests include software testing, test case generation, and machine
learning.
Hossein Shirazee
Hossein Shirazee received his B.S. in Software Engineering from
University Of Kashan, Isfahan, Iran. Currently, he is pursuing M.S. in
Software Engineering at Islamic Azad University, Qazvin Branch. His
research interests include software engineering, software testing, Service
Oriented Architecture, and cloud computing.
15International Journal of Software Engineering and Its Applications
Vol. 6, No. 4, October, 2012
16e-Informatica Software Engineering Journal, Volume 4, Issue 1, 2010
Automatic Test Cases Generation from
Software Specifications
Aysh Alhroob ∗ , Keshav Dahal ∗ , Alamgir Hossain ∗
∗
School of Computing , Informatics and Media, University of Bradford
amhalhro@ bradford.ac.uk, k.p.dahal@ bradford.ac.uk, m.a.hossain1@ bradford.ac.uk
Abstract
A new technique is proposed in this paper to extend the Integrated Classification Tree Method-
ology (ICTM) developed by Chen et al. [13] This software assists testers to construct test cases
from functional specifications. A Unified Modelling Language (UML) class diagram and Object
Constraint Language (OCL) are used in this paper to represent the software specifications. Each
classification and associated class in the software specification is represented by classes and at-
tributes in the class diagram. Software specification relationships are represented by associated
and hierarchical relationships in the class diagram. To ensure that relationships are consistent, an
automatic methodology is proposed to capture and control the class relationships in a systematic
way. This can help to reduce duplication and illegitimate test cases, which improves the testing
efficiency and minimises the time and cost of the testing. The methodology introduced in this
paper extracts only the legitimate test cases, by removing the duplicate test cases and those
incomputable with the software specifications. Large amounts of time would have been needed
to execute all of the test cases; therefore, a methodology was proposed which aimed to select a
best testing path. This path guarantees the highest coverage of system units and avoids using all
generated test cases. This path reduces the time and cost of the testing.
1. Introduction
Unified Modelling Language (UML) provides di-
agrams to help the software developer to repre-
sent different aspects of design. It has become a
standard modelling language for designing soft-
ware. UML represents the system specifications
that could be used in software testing. The com-
mon definition of software testing usually refers
to the testing of program code and not to the
testing of models used in earlier development
stages of the software development process, such
as requirements engineering, analysis or design.
Model testing could identify many faults earlier
and could, hence, decrease repair costs. A crit-
ical component of testing is the construction of
test cases. However, software testing is an expen-
sive and labour-intensive process; typically, test-
ing consumes at least 50% of the total costs in-
volved in developing software [7]. Software test-
ing has two important purposes. First, it is com-
monly used to expose the presence of faults in
software. Second, even if testing does not reveal
any fault, it still provides increased justification
and confidence in the correctness of the software
[18]. The Category Partition Method (CPM)
was developed by Ostrand and Balcer [19] to
generate test cases from functional specifications
using the concept of formal test specifications.
Several studies [2, 3] have been conducted which
focus on CPM. Recently, Chen et al. [14] en-
hanced the CPM, by means of their choice re-
lation framework. Based on CPM, Grochtmann
and Grimm [16] developed a similar but differ-
ent method – the Classification Tree Method
(CTM). Classification trees have been used to
construct test cases in the CTM. The absence
of a systematic tree construction algorithm is110
the major limitation of this method. As a re-
sult, users of this method are left with a loosely
defined task of constructing a Classification Tree
(Tu). For complex specifications, this construc-
tion task could be difficult, and hence, prone to
human error. If a Tu. is incorrectly constructed,
the quality of the resultant test cases generated
from it will be poorly affected. This problem is
solved by Chen et al. [13] who use Integrated
Classification Tree Methodology (ICTM). This
method helps with the identification of test cases
via the construction of classification trees. How-
ever, their tree constructed method is rather ad
hoc. This results in a variation of classification
trees constructed in CTM from one software
tester to the next, according to his/her personal
experience and expertise. A classification hier-
archy table (Hu) has been used in ICTM to al-
leviate this problem. The hierarchy table helps
to construct classification trees by capturing the
hierarchical relation for each pair of classifica-
tions.


